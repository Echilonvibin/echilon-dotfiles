#! /usr/bin/env python3
import subprocess
import json
import argparse
import os
from collections import defaultdict
import time


def get_hyprctl_binds():
    # ... (content remains the same for hyprctl fetching) ...
    while True:
        try:
            result = subprocess.run(
                ["hyprctl", "binds", "-j"], capture_output=True, text=True, check=True
            )
            while result.returncode != 0:
                print("Waiting for hyprctl command to succeed...")
                time.sleep(1)
                result = subprocess.run(
                    ["hyprctl", "binds", "-j"],
                    capture_output=True,
                    text=True,
                    check=True,
                )
            binds = json.loads(result.stdout)
            return binds
        except subprocess.CalledProcessError as e:
            print(f"Error executing hyprctl: {e}")
            return None
        except json.JSONDecodeError:
            time.sleep(1)


def parse_description(description):
    # ... (content remains the same for description parsing) ...
    if description.startswith("[") and "] " in description:
        headers, main_description = description.split("] ", 1)
        headers = headers.strip("[").split("|")
    else:
        headers = ["Misc", "", "", ""]
        main_description = description

    return {
        "header1": headers[0].replace("\\]", "]") if headers else "",
        "header2": headers[1].replace("\\]", "]") if len(headers) > 1 else "",
        "header3": headers[2].replace("\\]", "]") if len(headers) > 2 else "",
        "header4": headers[3].replace("\\]", "]") if len(headers) > 3 else "",
        "description": main_description,
    }


def map_dispatcher(dispatcher):
    # ... (content remains the same for dispatcher mapping) ...
    dispatcher_map = {
        "exec": "execute",
    }
    return dispatcher_map.get(dispatcher, dispatcher)


def map_codeDisplay(keycode, key):
    # ... (content remains the same for key code mapping) ...
    if keycode == 0:
        return key
    code_map = {
        61: "slash", 87: "KP_1", 88: "KP_2", 89: "KP_3", 83: "KP_4", 84: "KP_5",
        85: "KP_6", 79: "KP_7", 80: "KP_8", 81: "KP_9", 90: "KP_0",
    }
    return code_map.get(keycode, key)


def map_modDisplay(modmask):
    # ... (content remains the same for mod display mapping) ...
    modkey_map = {
        64: "SUPER", 32: "HYPER", 16: "META", 8: "ALT", 4: "CTRL", 2: "CAPSLOCK", 1: "SHIFT",
    }
    mod_display = []
    for key, name in sorted(modkey_map.items(), reverse=True):
        if modmask >= key:
            modmask -= key
            mod_display.append(name)
    return " ".join(mod_display) if mod_display else "None"


def map_keyDisplay(key):
    # ... (content remains the same for key display mapping) ...
    """Map key_display to a more descriptive term."""
    key_map = {
        "edge:r:d": "Touch right edge downwards",
        "edge:r:l": "Touch right edge left",
        "edge:r:r": "Touch right edge right",
    }
    return key_map.get(key, key)


def find_duplicated_binds(binds):
    # ... (content remains the same for finding duplicated binds) ...
    bind_map = defaultdict(list)
    for bind in binds:
        key = (bind["mod_display"], bind["key_display"])
        bind_map[key].append(bind)

    duplicated_binds = {k: v for v in bind_map.items() if len(v) > 1}
    return duplicated_binds


def generate_rofi(binds):
    """Generate rofi string for binds data with headers."""
    rofi_str = ""
    groups = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(list)))))

    # CRITICAL: Keep the SIX-SPACE separator for keybind rows.
    rofi_separator = '      ' # Six spaces

    # We use the visible '>' character as the descriptive delimiter
    delimiter = os.getenv("ROFI_KEYBIND_HINT_DELIMITER", ">")

    for bind in binds:
        catch_all = bind.get("catch_all", False)
        if catch_all:
            continue

        displayed_keys = bind["displayed_keys"]
        description = bind["description"]
        dispatcher = bind["dispatcher"]
        arg = bind["arg"]
        header1 = bind.get("header1", "")
        header2 = bind["header2"]
        header3 = bind["header3"]
        header4 = bind["header4"]
        header5 = bind.get("header5", "")
        submap = bind.get("submap", "")
        repeated = "repeat" if bind.get("repeat", False) else ""
        keycode = bind["keycode"]

        # Build the hidden metadata field for the keybind row
        meta_data = f"{dispatcher} {arg} {repeated} {keycode} {header1} {header2} {header3} {header4} {header5} {submap} {displayed_keys}"

        # Field 1 (Keybinds) - Left Column
        displayed_rofi_keys = f"{displayed_keys:<20}"
        # Field 2 (Description) - Right Column
        description_field = f"{delimiter} {description}"

        # Output format: Field 1 [6 SPACES] Field 2 [6 SPACES] Field 3 (Hidden Metadata)
        groups[header1][header2][header3][header4][header5].append(
            f"{displayed_rofi_keys}{rofi_separator}{description_field}{rofi_separator}{meta_data}"
        )

    def format_group(headers, level=0, parent_meta_data=""):
        nonlocal rofi_str

        # Adjust prefix based on level
        if level == 0:
            prefix = ""
        elif level == 1:
            prefix = "-> "
        else:
            prefix = " " * (level * 2) + "- "

        suffix = f"[{parent_meta_data}]" if parent_meta_data else ""

        for header, subgroups in headers.items():
            # current_meta_data = f"{header}{suffix}".strip(" <") # Metadata is now irrelevant for header output

            if header:
                # CRITICAL FIX: Format Header as a single line with NO DELIMITERS.
                # This forces Rofi to treat the entire line as Field 1, spanning the entire width,
                # and guarantees no metadata/delimiters leak.

                header_display = f"<span weight='bold'>{prefix}{header}</span>"

                # Output: ONLY the display text. No separators. No metadata.
                rofi_str += (
                    f"----{header_display}----\n"
                )

            if isinstance(subgroups, dict):
                format_group(subgroups, level + 1, header) # Pass the clean header string for the next level
            else:
                for binding in subgroups:
                    rofi_str += f"{binding}\n"

                # Separator: Use a full line with NO DELIMITERS.
                # Output: ONLY the separator dashes. No separators. No metadata.
                rofi_str += f"--------------------------------------------------------------------------------\n"

    format_group(groups)
    return rofi_str


def expand_meta_data(binds_data):
    # ... (content remains the same for expanding metadata) ...
    submap_keys = {}

    # First pass: collect submap keys
    for bind in binds_data:
        if bind.get("has_description", False):
            parsed_description = parse_description(bind["description"])
            bind.update(parsed_description)
        else:
            bind["description"] = f"{map_dispatcher(bind['dispatcher'])} {bind['arg']}"
            bind.update(
                {"header1": "Misc", "header2": "", "header3": "", "header4": ""}
            )
        bind["key"] = map_codeDisplay(bind["keycode"], bind["key"])
        bind["key_display"] = map_keyDisplay(bind["key"])
        bind["mod_display"] = map_modDisplay(bind["modmask"])

        # Handle submaps
        if bind["dispatcher"] == "submap":
            submap_name = bind["arg"]
            submap_keys[submap_name] = {
                "mod_display": bind["mod_display"],
                "key_display": bind["key_display"],
            }

    # Second pass: update binds with submap keys
    for bind in binds_data:
        submap = bind.get("submap", "")
        mod_display = bind["mod_display"]
        if mod_display is None or mod_display == "None":
            mod_display = ""
        key_display = bind["key_display"]
        if key_display is None or key_display == "None":
            key_display = ""
        keys = [mod_display] if mod_display else []
        if key_display:
            keys.append(key_display)
        formatted_keys = (
            " + ".join(keys).removeprefix(" + ").removesuffix(" + ")
        )

        if submap in submap_keys:
            submap_mod_display = submap_keys[submap]["mod_display"]
            submap_key_display = submap_keys[submap]["key_display"]
            bind["submap_mod"] = submap_mod_display
            bind["submap_key"] = submap_key_display
            bind["displayed_keys"] = (
                f"{submap_mod_display} + {submap_key_display} + "
                if submap_mod_display
                else ""
            ) + f"{formatted_keys}"
            bind["description"] = f"[{submap}] {bind['description']}"
        else:
            bind["submap_mod"] = ""
            bind["submap_key"] = ""
            bind["displayed_keys"] = formatted_keys


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Hyprland keybinds hint script")
    parser.add_argument(
        "--show-unbind", action="store_true", help="Show duplicated keybinds"
    )
    parser.add_argument(
        "--format",
        choices=["json", "md", "dmenu", "rofi"],
        default="json",
        help="Output format",
    )
    args = parser.parse_args()
    binds_data = get_hyprctl_binds()
    if binds_data:
        expand_meta_data(binds_data)
        if args.show_unbind:
            duplicated_binds = find_duplicated_binds(binds_data)
            for (mod_display, key_display), binds in duplicated_binds.items():
                print(f"unbind = {mod_display} , {key_display}")
        elif args.format == "json":
            print(json.dumps(binds_data, indent=4))
        elif args.format == "md":
            print(generate_md(binds_data))
        elif args.format == "dmenu":
            print(generate_dmenu(binds_data))
        elif args.format == "rofi":
            print(generate_rofi(binds_data))
